<!DOCTYPE html>
<html>
<head>
    <script src="https://telegram.org/js/telegram-web-app.js?59"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <style>
        * {
            box-sizing: border-box;
        }
        body { 
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            margin: 0; padding: 20px; 
            background: var(--tg-theme-bg-color, #ffffff);
            color: var(--tg-theme-text-color, #000000);
            min-height: 100vh;
            text-align: center;
            line-height: 1.4;
        }
        h1 {
            font-size: 24px;
            font-weight: 600;
            margin: 0 0 20px 0;
            color: var(--tg-theme-text-color);
        }
        button { 
            background: var(--tg-theme-button-color, #0088cc);
            color: var(--tg-theme-button-text-color, #ffffff) !important;
            border: none; 
            padding: 14px 20px; 
            border-radius: 12px; 
            font-size: 16px;
            font-weight: 500;
            cursor: pointer; 
            margin: 8px;
            width: 100%;
            max-width: 320px;
            transition: all 0.2s ease;
            user-select: none;
            -webkit-appearance: none;
        }
        button:hover {
            background: var(--tg-theme-button-color);
            opacity: 0.9;
        }
        button:active {
            transform: scale(0.98);
        }
        textarea, input {
            width: 100%; max-width: 400px;
            padding: 12px 16px;
            border-radius: 12px;
            border: 1px solid var(--tg-theme-hint-color, #c7c7c7);
            background: var(--tg-theme-secondary-bg-color, #f8f8f8);
            color: var(--tg-theme-text-color);
            font-size: 15px;
            margin: 8px 0;
            resize: vertical;
            font-family: inherit;
        }
        textarea {
            min-height: 120px;
            font-size: 14px;
        }
        textarea[readonly] {
            background: var(--tg-theme-hint-color);
            opacity: 0.7;
        }
        #status { 
            padding: 16px;
            border-radius: 12px;
            margin: 20px 0;
            font-weight: 500;
            background: var(--tg-theme-secondary-bg-color);
            border: 1px solid var(--tg-theme-hint-color);
        }
        video { 
            width: 100%; 
            max-height: 200px; 
            border-radius: 12px; 
            margin: 12px 0;
            background: var(--tg-theme-hint-color);
        }
        .container {
            max-width: 500px;
            margin: 0 auto;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üîó P2P WebRTC Call</h1>
        
        <div>
            <!-- Make buttons also copy when offer/answer ready -->
            <button onclick="getLocalOffer()" id="offerBtn">üì§ Create Offer</button>
            <button onclick="getLocalAnswer()" id="answerBtn">üì§ Create Answer</button>

        </div>
        
        <textarea id="copyData" 
                placeholder="Tap to copy!" 
                readonly 
                onclick="copyToClipboard()"
                onfocus="copyToClipboard()"></textarea>

        <!-- Add copy feedback -->
        <div id="copyFeedback" style="display:none; padding:12px; border-radius:12px; background:var(--tg-theme-button-color); color:var(--tg-theme-button-text-color); margin:8px 0; font-weight:500;"></div>
        
        <div>
            <input id="pasteData" placeholder="Paste peer's offer/answer here..." />
            <button onclick="useRemoteData()">üì• 3. Use Data</button>
        </div>
        
        <div id="status">Ready to create an offer</div>
        <div id="debugLog" style="background:var(--tg-theme-secondary-bg-color); border-radius:12px; padding:12px; margin:20px 0; font-size:14px; max-height:200px; overflow:auto; display:none;"></div>
        <button onclick="toggleDebug()" style="font-size:14px; padding:8px;">üîç Debug Log</button>

        
        <video id="localVideo" autoplay muted playsinline></video>
        <video id="remoteVideo" autoplay playsinline></video>
    </div>

    <script>
        Telegram.WebApp.ready();
        Telegram.WebApp.expand();
        
        // Dynamic theme matching
        document.documentElement.style.setProperty('--tg-theme-bg-color', Telegram.WebApp.themeParams.bg_color);
        document.documentElement.style.setProperty('--tg-theme-text-color', Telegram.WebApp.themeParams.text_color);
        document.documentElement.style.setProperty('--tg-theme-button-color', Telegram.WebApp.themeParams.button_color);
        document.documentElement.style.setProperty('--tg-theme-button-text-color', Telegram.WebApp.themeParams.button_text_color);
        document.documentElement.style.setProperty('--tg-theme-secondary-bg-color', Telegram.WebApp.themeParams.secondary_bg_color);
        document.documentElement.style.setProperty('--tg-theme-hint-color', Telegram.WebApp.themeParams.hint_color);

        const statusEl = document.getElementById('status');
        const copyEl = document.getElementById('copyData');
        const pasteEl = document.getElementById('pasteData');
        let pc, localStream;

        const config = { 
            iceServers: [{urls: 'stun:stun.l.google.com:19302'}] 
        };

        async function copyToClipboard() {
            const copyEl = document.getElementById('copyData');
            const feedbackEl = document.getElementById('copyFeedback');
            
            if (copyEl.value) {
                try {
                    await navigator.clipboard.writeText(copyEl.value);
                    
                    // Telegram haptic feedback
                    if (Telegram.WebApp.HapticFeedback) {
                        Telegram.WebApp.HapticFeedback.impactOccurred('light');
                    }
                    
                    // Visual feedback
                    feedbackEl.textContent = '‚úÖ Copied to clipboard!';
                    feedbackEl.style.display = 'block';
                    setTimeout(() => { feedbackEl.style.display = 'none'; }, 2000);
                    
                } catch (err) {
                    feedbackEl.textContent = '‚ùå Copy failed';
                    feedbackEl.style.display = 'block';
                }
            }
        }
        // Auto-copy styling for buttons
        document.getElementById('offerBtn').addEventListener('click', () => {
            setTimeout(() => {
                if (document.getElementById('copyData').value) {
                    copyToClipboard();
                }
            }, 1500); // After ICE gathering
        });

        // Auto-expand and theme updates
        Telegram.WebApp.onEvent('themeChanged', () => {
            document.documentElement.style.setProperty('--tg-theme-bg-color', Telegram.WebApp.themeParams.bg_color);
            document.documentElement.style.setProperty('--tg-theme-text-color', Telegram.WebApp.themeParams.text_color);
            // ... other theme params
        });

    let DEBUG = true;

    function log(message, data = null) {
        const timestamp = new Date().toLocaleTimeString();
        const logEl = document.getElementById('debugLog');
        const line = `[${timestamp}] ${message}`;
        logEl.innerHTML += line + '<br>';
        logEl.scrollTop = logEl.scrollHeight;
        console.log(line, data);
        if (DEBUG) document.getElementById('debugLog').style.display = 'block';
    }

    function toggleDebug() {
        const logEl = document.getElementById('debugLog');
        logEl.style.display = logEl.style.display === 'none' ? 'block' : 'none';
    }

    function clearLog() {
        document.getElementById('debugLog').innerHTML = '';
    }

    // Replace ALL error-prone functions with these:

    async function setupMedia() {
        log('üîÑ Stage 1: Requesting camera...');
        try {
            localStream = await navigator.mediaDevices.getUserMedia({
                video: { width: { ideal: 640 }, height: { ideal: 480 }, facingMode: 'user' }, 
                audio: true 
            });
            document.getElementById('localVideo').srcObject = localStream;
            log('‚úÖ Stage 1: Camera OK', { tracks: localStream.getTracks().length });
            statusEl.textContent = '‚úÖ Camera ready';
            return true;
        } catch (err) {
            log(`‚ùå Stage 1 FAILED: ${err.name} - ${err.message}`);
            statusEl.textContent = `‚ùå Camera: ${err.name}`;
            return false;
        }
    }

    async function getLocalOffer() {
        log('üöÄ Starting OFFER creation');
        const mediaReady = await setupMedia();
        if (!mediaReady) return;
        
        try {
            log('üîÑ Stage 2: Creating RTCPeerConnection');
            pc = new RTCPeerConnection(config);
            log('‚úÖ Stage 2: PeerConnection created');
            
            log('üîÑ Stage 3: Adding tracks', { trackCount: localStream.getTracks().length });
            localStream.getTracks().forEach(track => pc.addTrack(track, localStream));
            log('‚úÖ Stage 3: Tracks added');
            
            pc.ontrack = e => {
                log('üìπ Remote stream received');
                document.getElementById('remoteVideo').srcObject = e.streams[0];
            };
            
            log('üîÑ Stage 4: Waiting for ICE candidates...');
            pc.onicecandidate = (event) => {
                if (event.candidate) {
                    log('üßä ICE candidate gathered', { candidate: event.candidate.candidate });
                }
            };
            
            log('üîÑ Stage 5: Creating offer...');
            const offer = await pc.createOffer();
            log('‚úÖ Stage 5: Offer created', { type: offer.type, sdpLength: offer.sdp?.length });
            
            log('üîÑ Stage 6: Setting local description');
            await pc.setLocalDescription(offer);
            log('‚úÖ Stage 6: Local description set');
            
            // Wait for ICE gathering
            log('‚è≥ Waiting ICE complete...');
            setTimeout(() => {
                if (pc.iceGatheringState === 'complete') {
                    log('‚úÖ ICE gathering complete');
                    updateCopyData();
                } else {
                    log('‚ö†Ô∏è ICE not complete, forcing update');
                    updateCopyData();
                }
            }, 1000);
            
        } catch (err) {
            log(`‚ùå OFFER FAILED at stage: ${err.message}`, err);
            statusEl.textContent = `‚ùå Offer failed: ${err.message}`;
        }
    }

    async function getLocalAnswer() {
        log('üîÑ Starting ANSWER creation');
        try {
            log('üîÑ Stage 1: Parsing pasted data');
            const rawData = pasteEl.value.trim();
            if (!rawData) throw new Error('Empty paste data');
            
            const decoded = atob(rawData);
            log('‚úÖ Stage 1: Base64 decoded', { length: decoded.length });
            
            const remoteData = JSON.parse(decoded);
            log('‚úÖ Stage 2: JSON parsed', { 
                hasSdp: !!remoteData.sdp, 
                sdpLength: remoteData.sdp?.length 
            });
            
            if (!remoteData.sdp) throw new Error('No SDP in data');
            
            const mediaReady = await setupMedia();
            if (!mediaReady) throw new Error('Camera setup failed');
            
            log('üîÑ Stage 3: Creating peer connection for answer');
            pc = new RTCPeerConnection(config);
            localStream.getTracks().forEach(track => pc.addTrack(track, localStream));
            
            log('üîÑ Stage 4: Setting remote offer');
            await pc.setRemoteDescription({
                type: 'offer', 
                sdp: remoteData.sdp 
            });
            log('‚úÖ Stage 4: Remote offer set');
            
            log('üîÑ Stage 5: Creating answer');
            const answer = await pc.createAnswer();
            log('‚úÖ Stage 5: Answer created');
            
            log('üîÑ Stage 6: Setting local answer');
            await pc.setLocalDescription(answer);
            log('‚úÖ Stage 6: Answer set');
            
            // Wait ICE then copy
            setTimeout(updateCopyData, 1000);
            
        } catch (err) {
            log(`‚ùå ANSWER FAILED: ${err.message}`, { 
                pasteValue: pasteEl.value.substring(0, 100) + '...',
                error: err.stack 
            });
            statusEl.textContent = `‚ùå Invalid data: ${err.message}`;
        }
    }

    async function useRemoteData() {
        log('üîÑ Using remote ANSWER data');
        try {
            const rawData = pasteEl.value.trim();
            const decoded = atob(rawData);
            const remoteData = JSON.parse(decoded);
            
            log('‚úÖ Parsed answer data', { sdpLength: remoteData.sdp?.length });
            
            if (!pc) {
                log('‚ùå No peer connection exists');
                statusEl.textContent = '‚ùå Create offer first';
                return;
            }
            
            log('üîÑ Setting remote answer');
            await pc.setRemoteDescription({
                type: 'answer', 
                sdp: remoteData.sdp 
            });
            log('‚úÖ Remote answer set');
            
            statusEl.textContent = '‚úÖ Connected! Check video';
            
        } catch (err) {
            log(`‚ùå USE DATA FAILED: ${err.message}`, err);
            statusEl.textContent = `‚ùå Use failed: ${err.message}`;
        }
    }

    // Simplified copy data (just SDP for now)
    function updateCopyData() {
        if (!pc?.localDescription?.sdp) {
            log('‚ùå No local description to copy');
            return;
        }
        
        const data = { sdp: pc.localDescription.sdp };
        const compact = btoa(JSON.stringify(data));
        
        log('üìã Copy data ready', { 
            type: pc.localDescription.type, 
            sdpLength: data.sdp.length, 
            encodedLength: compact.length 
        });
        
        document.getElementById('copyData').value = compact;
        copyToClipboard();
    }

    </script>
</body>
</html>
